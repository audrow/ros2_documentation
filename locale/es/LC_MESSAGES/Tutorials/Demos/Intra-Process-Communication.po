# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, Open Robotics
# This file is distributed under the same license as the ROS 2 documentation
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: ROS 2 documentation\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-05-21 15:36+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: es <LL@li.org>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Generated-By: Babel 2.12.1\n"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:7
msgid "Setting up efficient intra-process communication"
msgstr "Establecer una comunicación intraproceso eficiente"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:11
msgid "Table of Contents"
msgstr "Table of Contents"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:14
msgid "Background"
msgstr "Historial"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:16
msgid ""
"ROS applications typically consist of a composition of individual \"nodes\" "
"which perform narrow tasks and are decoupled from other parts of the system."
" This promotes fault isolation, faster development, modularity, and code "
"reuse, but it often comes at the cost of performance. After ROS 1 was "
"initially developed, the need for efficient composition of nodes became "
"obvious and Nodelets were developed. In ROS 2 we aim to improve on the "
"design of Nodelets by addressing some fundamental problems that required "
"restructuring of nodes."
msgstr ""
"Las aplicaciones de ROS generalmente consisten en una composición de "
"\"nodos\" individuales que realizan tareas específicas y están desacoplados "
"de otras partes del sistema. Esto promueve el aislamiento de fallas, un "
"desarrollo más rápido, la modularidad y la reutilización de código, pero a "
"menudo tiene un costo de rendimiento. Después de que ROS 1 se desarrollara, "
"la necesidad de una composición eficiente de los nodos se hizo evidente y se"
" desarrollaron los Nodelets. En ROS 2, nuestro objetivo es mejorar el diseño"
" de Nodelets al abordar algunos problemas fundamentales que requirieron la "
"reestructuración de los nodos."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:21
msgid ""
"In this demo we'll be highlighting how nodes can be composed manually, by "
"defining the nodes separately but combining them in different process "
"layouts without changing the node's code or limiting its abilities."
msgstr ""
"En esta demo, destacaremos cómo los nodos se pueden componer manualmente, "
"definiéndolos por separado pero combinándolos en diferentes diseños de "
"procesos sin cambiar el código del nodo ni limitar sus capacidades."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:24
msgid "Installing the demos"
msgstr "Instalación de la demo"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:26
msgid ""
"See the :doc:`installation instructions <../../Installation>` for details on"
" installing ROS 2."
msgstr ""
"Consulte las :doc:`installation instructions <../../Installation>` para "
"obtener detalles sobre la instalación de ROS 2."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:28
msgid ""
"If you've installed ROS 2 from packages, ensure that you have ``ros-rolling-"
"intra-process-demo`` installed. If you downloaded the archive or built ROS 2"
" from source, it will already be part of the installation."
msgstr ""
"Si ha instalado ROS 2 desde paquetes, asegúrese de tener ``ros-rolling-"
"intra-process-demo`` instalado. Si descargó el archivo o creó ROS 2 desde "
"fuentes, ya será parte de la instalación."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:32
msgid "Running and understanding the demos"
msgstr "Ejecución y comprensión de las demos"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:34
msgid ""
"There are a few different demos: some are toy problems designed to highlight"
" features of the intra process communications functionality and some are end"
" to end examples which use OpenCV and demonstrate the ability to recombine "
"nodes into different configurations."
msgstr ""
"Hay diferentes demos: algunas son pequeños problemas diseñados para resaltar"
" características de la funcionalidad de comunicaciones dentro del proceso y "
"algunas son ejemplos complicados que usan OpenCV y demuestran la capacidad "
"de recombinar nodos en diferentes configuraciones."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:37
msgid "The two node pipeline demo"
msgstr "Demo de comunicación entre dos nodos"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:39
msgid ""
"This demo is designed to show that the intra process publish/subscribe "
"connection can result in zero-copy transport of messages when publishing and"
" subscribing with ``std::unique_ptr``\\ s."
msgstr ""
"Esta demo está diseñada para mostrar que la conexión de "
"publicación/suscripción dentro del proceso puede generar un transporte de "
"mensajes sin copia cuando se publica y se suscribe con "
"``std::unique_ptr``\\."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:41
msgid "First let's take a look at the source:"
msgstr "Primero echemos un vistazo al código:"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:43
msgid ""
"https://github.com/ros2/demos/blob/rolling/intra_process_demo/src/two_node_pipeline/two_node_pipeline.cpp"
msgstr ""
"https://github.com/ros2/demos/blob/rolling/intra_process_demo/src/two_node_pipeline/two_node_pipeline.cpp"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:127
msgid ""
"As you can see by looking at the ``main`` function, we have a producer and a"
" consumer node, we add them to a single threaded executor, and then call "
"spin."
msgstr ""
"Como puedes ver al observar la función ``main``, tenemos un nodo productor y"
" otro consumidor, los agregamos a un único ejecutor de subprocesos y luego "
"llamamos a spin."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:129
msgid ""
"If you look at the \"producer\" node's implementation in the ``Producer`` "
"struct, you can see that we have created a publisher which publishes on the "
"\"number\" topic and a timer which periodically creates a new message, "
"prints out its address in memory and its content's value and then publishes "
"it."
msgstr ""
"Si observas la implementación del nodo \"productor\" en la estructura "
"``Producer``, puedes ver que hemos creado un publicador que publica sobre el"
" topic \"number\" y un temporizador que periódicamente crea un nuevo "
"mensaje, imprime su dirección en la memoria y el valor de su contenido y "
"luego lo publica."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:131
msgid ""
"The \"consumer\" node is a bit simpler, you can see its implementation in "
"the ``Consumer`` struct, as it only subscribes to the \"number\" topic and "
"prints the address and value of the message it receives."
msgstr ""
"El nodo \"consumidor\" es un poco más simple, puedes ver su implementación "
"en la estructura ``Consumer``, ya que solo se suscribe al topic \"number\" e"
" imprime la dirección y el valor del mensaje que recibe."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:133
msgid ""
"The expectation is that the producer will print out an address and value and"
" the consumer will print out a matching address and value. This demonstrates"
" that intra process communication is indeed working and unnecessary copies "
"are avoided, at least for simple graphs."
msgstr ""
"La expectativa es que el productor imprimirá una dirección y un valor y el "
"consumidor imprimirá una dirección y un valor coincidentes. Esto demuestra "
"que la comunicación dentro del proceso funciona y se evitan copias "
"innecesarias, al menos para gráficos simples."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:136
msgid ""
"Let's run the demo by executing ``ros2 run intra_process_demo "
"two_node_pipeline`` executable (don't forget to source the setup file "
"first):"
msgstr ""
"Ejecutemos la demostración ejecutando ``ros2 run intra_process_demo "
"two_node_pipeline`` (no olvide hacer source del install.bash del paquete):"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:154
msgid ""
"One thing you'll notice is that the messages tick along at about one per "
"second. This is because we told the timer to fire at about once per second."
msgstr ""
"Una cosa que notará es que los mensajes avanzan aproximadamente uno por "
"segundo. Esto se debe a que le dijimos al temporizador que dispare "
"aproximadamente una vez por segundo."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:157
msgid ""
"Also you may have noticed that the first message (with value ``0``) does not"
" have a corresponding \"Received message ...\" line. This is because "
"publish/subscribe is \"best effort\" and we do not have any \"latching\" "
"like behavior enabled. This means that if the publisher publishes a message "
"before the subscription has been established, the subscription will not "
"receive that message. This race condition can result in the first few "
"messages being lost. In this case, since they only come once per second, "
"usually only the first message is lost."
msgstr ""
"También puedes haber notado que el primer mensaje (con valor ``0``) no tiene"
" una línea correspondiente de \"Mensaje recibido...\". Esto se debe a que "
"publicar/suscribir en \"best effort\" y no tenemos habilitado ningún "
"comportamiento similar al \"latching\". Esto significa que si el publicador "
"publica un mensaje antes de que se haya establecido la suscripción, la "
"suscripción no recibirá ese mensaje. Esta condición de carrera puede "
"provocar la pérdida de los primeros mensajes. En este caso, como solo llegan"
" una vez por segundo, normalmente solo se pierde el primer mensaje."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:163
msgid ""
"Finally, you can see that \"Published message...\" and \"Received message "
"...\" lines with the same value also have the same address. This shows that "
"the address of the message being received is the same as the one that was "
"published and that it is not a copy. This is because we're publishing and "
"subscribing with ``std::unique_ptr``\\ s which allow ownership of a message "
"to be moved around the system safely. You can also publish and subscribe "
"with ``const &`` and ``std::shared_ptr``, but zero-copy will not occur in "
"that case."
msgstr ""
"Finalmente, puedes ver que las líneas \"Published message..\" y \"Received "
"message ...\" con el mismo valor también tienen la misma dirección. Esto "
"demuestra que la dirección del mensaje que se recibe es la misma que la que "
"se publicó y que no es una copia. Esto se debe a que estamos publicando y "
"suscribiéndonos con ``std::unique_ptr``\\ s que permiten que la propiedad de"
" un mensaje se mueva por el sistema de forma segura. También puedes publicar"
" y suscribirse con ``const &`` y ``std::shared_ptr``, pero en ese caso no se"
" producirá copia cero."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:169
msgid "The cyclic pipeline demo"
msgstr "La demostración de comunicación cíclica"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:171
msgid ""
"This demo is similar to the previous one, but instead of the producer "
"creating a new message for each iteration, this demo only ever uses one "
"message instance. This is achieved by creating a cycle in the graph and "
"\"kicking off\" communication by externally making one of the nodes publish "
"before spinning the executor:"
msgstr ""
"Esta demo es similar a la anterior, pero en lugar de que el productor cree "
"un nuevo mensaje para cada iteración, esta demo solo usa una instancia de "
"mensaje. Esto se logra mediante la creación de un ciclo en el gráfico y el "
"\"kicking off\" de la comunicación al hacer que uno de los nodos publique "
"externamente antes de hacer girar el ejecutor:"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:174
msgid ""
"https://github.com/ros2/demos/blob/rolling/intra_process_demo/src/cyclic_pipeline/cyclic_pipeline.cpp"
msgstr ""
"https://github.com/ros2/demos/blob/rolling/intra_process_demo/src/cyclic_pipeline/cyclic_pipeline.cpp"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:256
msgid ""
"Unlike the previous demo, this demo uses only one Node, instantiated twice "
"with different names and configurations. The graph ends up being ``pipe1`` "
"-> ``pipe2`` -> ``pipe1`` ... in a loop."
msgstr ""
"A diferencia de la demo anterior, esta demo usa solo un Nodo, instanciado "
"dos veces con diferentes nombres y configuraciones. El gráfico termina "
"siendo ``pipe1`` -> ``pipe2`` -> ``pipe3`` ... en un bucle."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:259
msgid ""
"The line ``pipe1->pub->publish(msg);`` kicks the process off, but from then "
"on the messages are passed back and forth between the nodes by each one "
"calling publish within its own subscription callback."
msgstr ""
"La línea ``pipe1->pub->publish(msg);`` inicia el proceso, pero a partir de "
"ese momento, los mensajes se pasan de un lado a otro entre los nodos y cada "
"uno llama a la publicación dentro de su propio callback de suscripción."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:261
msgid ""
"The expectation here is that the nodes pass the message back and forth, once"
" a second, incrementing the value of the message each time. Because the "
"message is being published and subscribed to as a ``unique_ptr`` the same "
"message created at the beginning is continuously used."
msgstr ""
"La expectativa aquí es que los nodos pasen el mensaje de un lado a otro, una"
" vez por segundo, incrementando el valor del mensaje cada vez. Debido a que "
"el mensaje se publica y se suscribe como ``unique_ptr``, se usa "
"continuamente el mismo mensaje creado al principio."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:264
msgid "To test those expectations, let's run it:"
msgstr "Para probar esas expectativas, ejecútelo:"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:294
msgid ""
"You should see ever increasing numbers on each iteration, starting with "
"42... because 42, and the whole time it reuses the same message, as "
"demonstrated by the pointer addresses which do not change, which avoids "
"unnecessary copies."
msgstr ""
"Deberías ver números cada vez mayores en cada iteración, comenzando con "
"42... porque 42, y todo el tiempo reutiliza el mismo mensaje, como lo "
"demuestran las direcciones de puntero que no cambian, lo que evita copias "
"innecesarias."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:297
msgid "The image pipeline demo"
msgstr "La demo de comunicación de imágenes"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:299
msgid ""
"In this demo we'll use OpenCV to capture, annotate, and then view images."
msgstr ""
"En esta demo, usaremos OpenCV para capturar, anotar y luego ver imágenes."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:303
msgid ""
"If you are on macOS and these examples do not work or you receive an error "
"like ``ddsi_conn_write failed -1``, then you'll need to increase your system"
" wide UDP packet size:"
msgstr ""
"Si está en macOS y estos ejemplos no funcionan o recibe un error como "
"``ddsi_conn_write fail -1``, entonces deberá aumentar el tamaño del paquete "
"UDP en todo el sistema:"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:310
msgid "These changes will not persist after a reboot."
msgstr "Estos cambios no persistirán después de un reinicio."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:313
msgid "Simple pipeline"
msgstr "Comunicación simple"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:315
msgid ""
"First we'll have a pipeline of three nodes, arranged as such: "
"``camera_node`` -> ``watermark_node`` -> ``image_view_node``"
msgstr ""
"Primero tendremos una comunicación de tres nodos, dispuestos de la siguiente"
" manera: ``camera_node`` -> ``watermark_node`` -> ``image_view_node``"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:317
msgid ""
"The ``camera_node`` reads from camera device ``0`` on your computer, writes "
"some information on the image and publishes it. The ``watermark_node`` "
"subscribes to the output of the ``camera_node`` and adds more text before "
"publishing it too. Finally, the ``image_view_node`` subscribes to the output"
" of the ``watermark_node``, writes more text to the image and then "
"visualizes it with ``cv::imshow``."
msgstr ""
"El ``camera_node`` lee desde el dispositivo de cámara ``0`` en su "
"computadora, escribe alguna información en la imagen y la publica. "
"``watermark_node`` se suscribe a la salida de ``camera_node`` y agrega más "
"texto antes de publicarlo también. Finalmente, ``image_view_node`` se "
"suscribe a la salida de ``watermark_node``, escribe más texto en la imagen y"
" luego la visualiza con ``cv::imshow``."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:321
msgid ""
"In each node the address of the message which is being sent, or which has "
"been received, or both, is written to the image. The watermark and image "
"view nodes are designed to modify the image without copying it and so the "
"addresses imprinted on the image should all be the same as long as the nodes"
" are in the same process and the graph remains organized in a pipeline as "
"sketched above."
msgstr ""
"En cada nodo se escribe en la imagen la dirección del mensaje que se está "
"enviando, o el que se ha recibido, o ambos. Los nodos de marca de agua y "
"vista de imagen están diseñados para modificar la imagen sin copiarla, por "
"lo que las direcciones impresas en la imagen deben ser todas iguales siempre"
" que los nodos estén en el mismo proceso y el gráfico permanezca organizado "
"en una canalización como se muestra arriba."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:326
msgid ""
"On some systems (we've seen it happen on Linux), the address printed to the "
"screen might not change. This is because the same unique pointer is being "
"reused. In this situation, the pipeline is still running."
msgstr ""
"En algunos sistemas (lo hemos visto en Linux), es posible que la dirección "
"impresa en la pantalla no cambie. Esto se debe a que se está reutilizando el"
" mismo puntero único. En esta situación, la canalización aún se está "
"ejecutando."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:329
msgid "Let's run the demo by executing the following executable:"
msgstr "Ejecutemos la demostración ejecutando el siguiente ejecutable:"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:335
msgid "You should see something like this:"
msgstr "Deberías ver algo como esto:"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:341
msgid ""
"You can pause the rendering of the image by pressing the spacebar and you "
"can resume by pressing the spacebar again. You can also press ``q`` or "
"``ESC`` to exit."
msgstr ""
"Puedes pausar la representación de la imagen presionando la barra "
"espaciadora y puedes reanudarla presionando la barra espaciadora nuevamente."
" También puede presionar ``q`` o ``ESC`` para salir."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:344
msgid ""
"If you pause the image viewer, you should be able to compare the addresses "
"written on the image and see that they are the same."
msgstr ""
"Si pausas el visor de imágenes, debería poder comparar las direcciones "
"escritas en la imagen y ver que son iguales."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:347
msgid "Pipeline with two image viewers"
msgstr "Comunicación con dos visualizadores de imágenes"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:349
msgid ""
"Now let's look at an example just like the one above, except it has two "
"image view nodes. All the nodes are still in the same process, but now two "
"image view windows should show up. (Note for macOS users: your image view "
"windows might be on top of each other). Let's run it with the command:"
msgstr ""
"Ahora veamos un ejemplo como el de arriba, excepto que tiene dos nodos de "
"visualización de imagen. Todos los nodos todavía están en el mismo proceso, "
"pero ahora deberían aparecer dos ventanas de visualización de imágenes. "
"(Nota para los usuarios de macOS: las ventanas de visualización de imágenes "
"pueden estar una encima de la otra). Vamos a ejecutarlo con el comando:"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:361
msgid ""
"Just like the last example, you can pause the rendering with the spacebar "
"and continue by pressing the spacebar a second time. You can stop the "
"updating to inspect the pointers written to the screen."
msgstr ""
"Al igual que en el último ejemplo, puede pausar el renderizado con la barra "
"espaciadora y continuar presionando la barra espaciadora por segunda vez. "
"Puede detener la actualización para inspeccionar los punteros escritos en la"
" pantalla."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:363
msgid ""
"As you can see in the example image above, we have one image with all of the"
" pointers the same and then another image with the same pointers as the "
"first image for the first two entries, but the last pointer on the second "
"image is different. To understand why this is happening consider the graph's"
" topology:"
msgstr ""
"Como puedes ver en la imagen de ejemplo anterior, tenemos una imagen con "
"todos los punteros iguales y luego otra imagen con los mismos punteros que "
"la primera imagen para las dos primeras entradas, pero el último puntero en "
"la segunda imagen es diferente. Para entender por qué sucede esto, considere"
" la topología del gráfico:"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:370
msgid ""
"The link between the ``camera_node`` and the ``watermark_node`` can use the "
"same pointer without copying because there is only one intra process "
"subscription to which the message should be delivered. But for the link "
"between the ``watermark_node`` and the two image view nodes the relationship"
" is one to many, so if the image view nodes were using ``unique_ptr`` "
"callbacks then it would be impossible to deliver the ownership of the same "
"pointer to both. It can be, however, delivered to one of them. Which one "
"would get the original pointer is not defined, but instead is simply the "
"last to be delivered."
msgstr ""
"El enlace entre ``camera_node`` y ``watermark_node`` puede usar el mismo "
"puntero sin copiar porque solo hay una suscripción dentro del proceso a la "
"que se debe entregar el mensaje. Pero para el enlace entre "
"``watermark_node`` y los dos nodos de visualización de imagen, la relación "
"es de uno a muchos, por lo que si los nodos de vista de imagen estuvieran "
"usando callbacks ``unique_ptr``, entonces sería imposible entregar la "
"propiedad del mismo puntero a ambos. Puede ser, sin embargo, entregado a uno"
" de ellos. No se define cuál obtendría el puntero original, sino que es "
"simplemente el último en ser entregado."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:372
msgid ""
"Note that the image view nodes are not subscribed with ``unique_ptr`` "
"callbacks. Instead they are subscribed with ``const shared_ptr``\\ s. This "
"means the system deliveres the same ``shared_ptr`` to both callbacks. When "
"the first intraprocess subscription is handled, the internally stored "
"``unique_ptr`` is promoted to a ``shared_ptr``. Each of the callbacks will "
"receive shared ownership of the same message."
msgstr ""
"Ten en cuenta que los nodos de visualización de imagen no están suscritos "
"con callbacks ``unique_ptr``. En su lugar, están suscritos con ``const "
"shared_ptr``\\ s. Esto significa que el sistema entrega el mismo "
"``shared_ptr`` a ambos callbacks. Cuando se maneja la primera suscripción "
"dentro del proceso, el ``unique_ptr`` almacenado internamente se promociona "
"a ``shared_ptr``. Cada uno de los callbacks recibirá la propiedad compartida"
" del mismo mensaje."

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:375
msgid "Pipeline with interprocess viewer"
msgstr "Comunicacion con visualización entre procesos"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:377
msgid ""
"One other important thing to get right is to avoid interruption of the intra"
" process zero-copy behavior when interprocess subscriptions are made. To "
"test this we can run the first image pipeline demo, "
"``image_pipeline_all_in_one``, and then run an instance of the stand alone "
"``image_view_node`` (don't forget to prefix them with ``ros2 run "
"intra_process_demo`` in the terminal). This will look something like this:"
msgstr ""
"Otra cosa importante para hacerlo bien es evitar la interrupción del "
"comportamiento de copia cero dentro del proceso cuando se realizan "
"suscripciones entre procesos. Para probar esto, podemos ejecutar la "
"demostración de canalización de la primera imagen, "
"``image_pipeline_all_in_one``, y luego ejecutar una instancia del "
"independiente ``image_view_node`` (no olvide ponerles el prefijo ``ros2 run "
"intra_process_demo`` en el Terminal). Esto se verá algo como esto:"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:383
msgid ""
"It's hard to pause both images at the same time so the images may not line "
"up, but the important thing to notice is that the "
"``image_pipeline_all_in_one`` image view shows the same address for each "
"step. This means that the intra process zero-copy is preserved even when an "
"external view is subscribed as well. You can also see that the interprocess "
"image view has different process IDs for the first two lines of text and the"
" process ID of the standalone image viewer in the third line of text."
msgstr ""
"Es difícil pausar ambas imágenes al mismo tiempo, por lo que es posible que "
"las imágenes no se alineen, pero lo importante a tener en cuenta es que la "
"vista de imagen ``image_pipeline_all_in_one`` muestra la misma dirección "
"para cada paso. Esto significa que la copia cero dentro del proceso se "
"conserva incluso cuando también se suscribe una vista externa. También "
"puedes ver que la vista de imagen entre procesos tiene ID de proceso "
"diferentes para las dos primeras líneas de texto y la ID de proceso del "
"visor de imágenes independiente en la tercera línea de texto."
