# Archivo de traducción al español para la documentación de ROS 2.
# Copyright (C) 2023, Open Robotics
# This file is distributed under the same license as the ROS 2 documentation
# package.
# Cristian Chitiva <cychitivav@unal.edu.co>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: ROS 2 documentation\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-08-19 11:55+0000\n"
"Language-Team: es <LL@li.org>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1)\n"
"Generated-By: Babel 2.8.0\n"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:7
#: 587389048cda43f8ae66b75fd8cf94df
msgid "Setting up efficient intra-process communication"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:11
#: f8c63f9ac0944f1085d16bd6554b193c
msgid "Table of Contents"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:14
#: baad1180a59d439e9c8a34f238aefb42
msgid "Background"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:16
#: 83883cdc5eb04599b3080826677bd0b8
msgid ""
"ROS applications typically consist of a composition of individual "
"\"nodes\" which perform narrow tasks and are decoupled from other parts "
"of the system. This promotes fault isolation, faster development, "
"modularity, and code reuse, but it often comes at the cost of "
"performance. After ROS 1 was initially developed, the need for efficient "
"composition of nodes became obvious and Nodelets were developed. In ROS 2"
" we aim to improve on the design of Nodelets by addressing some "
"fundamental problems that required restructuring of nodes."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:21
#: 40deadf3ac78479fb74d36f2aa40d872
msgid ""
"In this demo we'll be highlighting how nodes can be composed manually, by"
" defining the nodes separately but combining them in different process "
"layouts without changing the node's code or limiting its abilities."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:24
#: f1cef71970b74f42a6461bc50ade4c9b
msgid "Installing the demos"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:26
#: a88223985dda42ce9f2dfbc46cbe75cd
msgid ""
"See the :doc:`installation instructions <../../Installation>` for details"
" on installing ROS 2."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:28
#: d2e234af5ca142918c50fb0dcf058f25
msgid ""
"If you've installed ROS 2 from packages, ensure that you have "
"``ros-{DISTRO}-intra-process-demo`` installed. If you downloaded the "
"archive or built ROS 2 from source, it will already be part of the "
"installation."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:32
#: a7ba18511c6a4580ac39e24ac134505e
msgid "Running and understanding the demos"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:34
#: 8886b967960c4b229afe0581accbddb8
msgid ""
"There are a few different demos: some are toy problems designed to "
"highlight features of the intra process communications functionality and "
"some are end to end examples which use OpenCV and demonstrate the ability"
" to recombine nodes into different configurations."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:37
#: 4f22e0d6553c47b4b5b2cd260b97c8f9
msgid "The two node pipeline demo"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:39
#: 318814257855431ca9e201a48f4b91de
msgid ""
"This demo is designed to show that the intra process publish/subscribe "
"connection can result in zero-copy transport of messages when publishing "
"and subscribing with ``std::unique_ptr``\\ s."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:41
#: 1831ef841f304a79b0f606aa6fc2b4b0
msgid "First let's take a look at the source:"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:43
#: a3e3d893b691432680bee579f9fdf7d7
msgid "https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/intra_process_demo/src/two_node_pipeline/two_node_pipeline.cpp"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:127
#: 8b8aae74a3374f70881726b8482cb4fa
msgid ""
"As you can see by looking at the ``main`` function, we have a producer "
"and a consumer node, we add them to a single threaded executor, and then "
"call spin."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:129
#: a35a985bb08842269b9ae55f7fbd16bd
msgid ""
"If you look at the \"producer\" node's implementation in the ``Producer``"
" struct, you can see that we have created a publisher which publishes on "
"the \"number\" topic and a timer which periodically creates a new "
"message, prints out its address in memory and its content's value and "
"then publishes it."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:131
#: 6e30997a8e84477797ce7988e1c9f966
msgid ""
"The \"consumer\" node is a bit simpler, you can see its implementation in"
" the ``Consumer`` struct, as it only subscribes to the \"number\" topic "
"and prints the address and value of the message it receives."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:133
#: a762fa0cd8d34600bade1589a358efd4
msgid ""
"The expectation is that the producer will print out an address and value "
"and the consumer will print out a matching address and value. This "
"demonstrates that intra process communication is indeed working and "
"unnecessary copies are avoided, at least for simple graphs."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:136
#: eaa831f9cbee463ba4f9d3f1c415f1dc
msgid ""
"Let's run the demo by executing ``ros2 run intra_process_demo "
"two_node_pipeline`` executable (don't forget to source the setup file "
"first):"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:154
#: b99be9d23c93459e98257664930d2976
msgid ""
"One thing you'll notice is that the messages tick along at about one per "
"second. This is because we told the timer to fire at about once per "
"second."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:157
#: 3cbf4bee8dfb4e60bf02f1a941725deb
msgid ""
"Also you may have noticed that the first message (with value ``0``) does "
"not have a corresponding \"Received message ...\" line. This is because "
"publish/subscribe is \"best effort\" and we do not have any \"latching\" "
"like behavior enabled. This means that if the publisher publishes a "
"message before the subscription has been established, the subscription "
"will not receive that message. This race condition can result in the "
"first few messages being lost. In this case, since they only come once "
"per second, usually only the first message is lost."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:163
#: 315397c3bb0d487784e41e9029f5718c
msgid ""
"Finally, you can see that \"Published message...\" and \"Received message"
" ...\" lines with the same value also have the same address. This shows "
"that the address of the message being received is the same as the one "
"that was published and that it is not a copy. This is because we're "
"publishing and subscribing with ``std::unique_ptr``\\ s which allow "
"ownership of a message to be moved around the system safely. You can also"
" publish and subscribe with ``const &`` and ``std::shared_ptr``, but "
"zero-copy will not occur in that case."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:169
#: f3cc092082714b00989f524f37d0ceb6
msgid "The cyclic pipeline demo"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:171
#: 0b28d891b81e4f6ab9d0f5fb86cc547b
msgid ""
"This demo is similar to the previous one, but instead of the producer "
"creating a new message for each iteration, this demo only ever uses one "
"message instance. This is achieved by creating a cycle in the graph and "
"\"kicking off\" communication by externally making one of the nodes "
"publish before spinning the executor:"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:174
#: 78889b11aeba4bd284035d50f0d4a6c4
msgid "https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/intra_process_demo/src/cyclic_pipeline/cyclic_pipeline.cpp"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:256
#: c62e474fad664549a3c9880ccef0bea4
msgid ""
"Unlike the previous demo, this demo uses only one Node, instantiated "
"twice with different names and configurations. The graph ends up being "
"``pipe1`` -> ``pipe2`` -> ``pipe1`` ... in a loop."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:259
#: 7158dd75f6fa4ba28242c67979e4a1fe
msgid ""
"The line ``pipe1->pub->publish(msg);`` kicks the process off, but from "
"then on the messages are passed back and forth between the nodes by each "
"one calling publish within its own subscription callback."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:261
#: 4ff1724b4d0943a28a6fde901c536262
msgid ""
"The expectation here is that the nodes pass the message back and forth, "
"once a second, incrementing the value of the message each time. Because "
"the message is being published and subscribed to as a ``unique_ptr`` the "
"same message created at the beginning is continuously used."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:264
#: 1960a288b5a84fc1873722aacbc27a27
msgid "To test those expectations, let's run it:"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:294
#: 864737ba1583469aa93ca7a432c0c590
msgid ""
"You should see ever increasing numbers on each iteration, starting with "
"42... because 42, and the whole time it reuses the same message, as "
"demonstrated by the pointer addresses which do not change, which avoids "
"unnecessary copies."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:297
#: 1993833325524fb99280e29b9494a367
msgid "The image pipeline demo"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:299
#: 86eb7648e4f9470b92078d89ca3f8cfa
msgid "In this demo we'll use OpenCV to capture, annotate, and then view images."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:303
#: 784fec58fc994872bb9f5fac6e3c6612
msgid ""
"If you are on macOS and these examples do not work or you receive an "
"error like ``ddsi_conn_write failed -1``, then you'll need to increase "
"your system wide UDP packet size:"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:310
#: 58f0a20614414036b684e2ff9c1686e0
msgid "These changes will not persist after a reboot."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:313
#: 6ce81745094a4ed98e0a759ebf321558
msgid "Simple pipeline"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:315
#: 105518258b9c45c283785e745f6b281f
msgid ""
"First we'll have a pipeline of three nodes, arranged as such: "
"``camera_node`` -> ``watermark_node`` -> ``image_view_node``"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:317
#: 1cde4d2ce7b7452ab85a86f218496ee4
msgid ""
"The ``camera_node`` reads from camera device ``0`` on your computer, "
"writes some information on the image and publishes it. The "
"``watermark_node`` subscribes to the output of the ``camera_node`` and "
"adds more text before publishing it too. Finally, the ``image_view_node``"
" subscribes to the output of the ``watermark_node``, writes more text to "
"the image and then visualizes it with ``cv::imshow``."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:321
#: 575a27ed5ec64ef49836134315008d03
msgid ""
"In each node the address of the message which is being sent, or which has"
" been received, or both, is written to the image. The watermark and image"
" view nodes are designed to modify the image without copying it and so "
"the addresses imprinted on the image should all be the same as long as "
"the nodes are in the same process and the graph remains organized in a "
"pipeline as sketched above."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:326
#: c353e86a5b924236a466bcfc7ba1b1f6
msgid ""
"On some systems (we've seen it happen on Linux), the address printed to "
"the screen might not change. This is because the same unique pointer is "
"being reused. In this situation, the pipeline is still running."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:329
#: 080727d3ca4f41f087cdd829aec2b2eb
msgid "Let's run the demo by executing the following executable:"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:335
#: 275bb855e3414a03b74860913ca6339b
msgid "You should see something like this:"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:341
#: 4c9bc1bac4104746b3c05956a46870e6
msgid ""
"You can pause the rendering of the image by pressing the spacebar and you"
" can resume by pressing the spacebar again. You can also press ``q`` or "
"``ESC`` to exit."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:344
#: 65593e8ba1894d0cbcee4379879f0547
msgid ""
"If you pause the image viewer, you should be able to compare the "
"addresses written on the image and see that they are the same."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:347
#: dba732cec9ed4b769f334865534da921
msgid "Pipeline with two image viewers"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:349
#: ce496e6d5ce64ef3b6719040cbf44ce6
msgid ""
"Now let's look at an example just like the one above, except it has two "
"image view nodes. All the nodes are still in the same process, but now "
"two image view windows should show up. (Note for macOS users: your image "
"view windows might be on top of each other). Let's run it with the "
"command:"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:361
#: 6a145052011c4d4da69ce08477c27229
msgid ""
"Just like the last example, you can pause the rendering with the spacebar"
" and continue by pressing the spacebar a second time. You can stop the "
"updating to inspect the pointers written to the screen."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:363
#: 2aafb747b4e844a988570b7ba62497e2
msgid ""
"As you can see in the example image above, we have one image with all of "
"the pointers the same and then another image with the same pointers as "
"the first image for the first two entries, but the last pointer on the "
"second image is different. To understand why this is happening consider "
"the graph's topology:"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:370
#: ec77304a885145ee88d31228a1ab647b
msgid ""
"The link between the ``camera_node`` and the ``watermark_node`` can use "
"the same pointer without copying because there is only one intra process "
"subscription to which the message should be delivered. But for the link "
"between the ``watermark_node`` and the two image view nodes the "
"relationship is one to many, so if the image view nodes were using "
"``unique_ptr`` callbacks then it would be impossible to deliver the "
"ownership of the same pointer to both. It can be, however, delivered to "
"one of them. Which one would get the original pointer is not defined, but"
" instead is simply the last to be delivered."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:372
#: 26ac23cf766b4a9595c1252e10ce5f13
msgid ""
"Note that the image view nodes are not subscribed with ``unique_ptr`` "
"callbacks. Instead they are subscribed with ``const shared_ptr``\\ s. "
"This means the system deliveres the same ``shared_ptr`` to both "
"callbacks. When the first intraprocess subscription is handled, the "
"internally stored ``unique_ptr`` is promoted to a ``shared_ptr``. Each of"
" the callbacks will receive shared ownership of the same message."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:375
#: 2e373ffa6e6e45368c3f2836d7b00e0c
msgid "Pipeline with interprocess viewer"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:377
#: 0a0235a88199469c999e24e380682cc2
msgid ""
"One other important thing to get right is to avoid interruption of the "
"intra process zero-copy behavior when interprocess subscriptions are "
"made. To test this we can run the first image pipeline demo, "
"``image_pipeline_all_in_one``, and then run an instance of the stand "
"alone ``image_view_node`` (don't forget to prefix them with ``ros2 run "
"intra_process_demo`` in the terminal). This will look something like "
"this:"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:383
#: ce1fcca59b7f492d84723744ea43ba91
msgid ""
"It's hard to pause both images at the same time so the images may not "
"line up, but the important thing to notice is that the "
"``image_pipeline_all_in_one`` image view shows the same address for each "
"step. This means that the intra process zero-copy is preserved even when "
"an external view is subscribed as well. You can also see that the "
"interprocess image view has different process IDs for the first two lines"
" of text and the process ID of the standalone image viewer in the third "
"line of text."
msgstr ""

#~ msgid ""
#~ "If you've installed ROS 2 from "
#~ "packages, ensure that you have ``ros-"
#~ "rolling-intra-process-demo`` installed. "
#~ "If you downloaded the archive or "
#~ "built ROS 2 from source, it will"
#~ " already be part of the installation."
#~ msgstr ""

#~ msgid "https://github.com/ros2/demos/blob/rolling/intra_process_demo/src/two_node_pipeline/two_node_pipeline.cpp"
#~ msgstr ""

#~ msgid "https://github.com/ros2/demos/blob/rolling/intra_process_demo/src/cyclic_pipeline/cyclic_pipeline.cpp"
#~ msgstr ""

