# Archivo de traducción al español para la documentación de ROS 2.
# Copyright (C) 2023, Open Robotics
# This file is distributed under the same license as the ROS 2 documentation
# package.
# Cristian Chitiva <cychitivav@unal.edu.co>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: ROS 2 documentation\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-08-19 11:55+0000\n"
"Language-Team: es <LL@li.org>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1)\n"
"Generated-By: Babel 2.8.0\n"

#: ../../source/Concepts/Intermediate/About-Executors.rst:6
#: 973e27ad070f4b6ca760661fd2566126
msgid "Executors"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:9
#: fe92a2b8c6f44b52af51c921442fda29
msgid "Table of Contents"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:12
#: 1f8fb2fba2ef4ca1a9234c62e7da4866
msgid "Overview"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:14
#: 5e4f9f7e0e6f4982af843ed3f1c531ed
msgid ""
"Execution management in ROS 2 is handled by Executors. An Executor uses "
"one or more threads of the underlying operating system to invoke the "
"callbacks of subscriptions, timers, service servers, action servers, etc."
" on incoming messages and events. The explicit Executor class (in "
"`executor.hpp "
"<https://github.com/ros2/rclcpp/blob/{REPOS_FILE_BRANCH}/rclcpp/include/rclcpp/executor.hpp>`_"
" in rclcpp, in `executors.py "
"<https://github.com/ros2/rclpy/blob/{REPOS_FILE_BRANCH}/rclpy/rclpy/executors.py>`_"
" in rclpy, or in `executor.h "
"<https://github.com/ros2/rclc/blob/master/rclc/include/rclc/executor.h>`_"
" in rclc) provides more control over execution management than the spin "
"mechanism in ROS 1, although the basic API is very similar."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:18
#: 6588527a9ab845d78b69cfcd34427e49
msgid "In the following, we focus on the C++ Client Library *rclcpp*."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:21
#: 71d79e19eba84d4aa29aad2a292a6f76
msgid "Basic use"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:23
#: 78b5cc3a56b6412ab5ac9cbf1911dc94
msgid ""
"In the simplest case, the main thread is used for processing the incoming"
" messages and events of a Node by calling ``rclcpp::spin(..)`` as "
"follows:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:44
#: e97f28ea3e2d4aa5866f0704fe754639
msgid ""
"The call to ``spin(node)`` basically expands to an instantiation and "
"invocation of the Single-Threaded Executor, which is the simplest "
"Executor:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:52
#: 2ef7ba8742bc413d820ed03c67f7d39d
msgid ""
"By invoking ``spin()`` of the Executor instance, the current thread "
"starts querying the rcl and middleware layers for incoming messages and "
"other events and calls the corresponding callback functions until the "
"node shuts down. In order not to counteract the QoS settings of the "
"middleware, an incoming message is not stored in a queue on the Client "
"Library layer but kept in the middleware until it is taken for processing"
" by a callback function. (This is a crucial difference to ROS 1.) A *wait"
" set* is used to inform the Executor about available messages on the "
"middleware layer, with one binary flag per queue. The *wait set* is also "
"used to detect when timers expire."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:60
#: d54caafee4e54b9c9aaf8ee43e30f2eb
msgid ""
"The Single-Threaded Executor is also used by the container process for "
":doc:`components <./About-Composition>`, i.e. in all cases where nodes "
"are created and executed without an explicit main function."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:63
#: e94f2553303c440fa2d101748dd7cc4a
msgid "Types of Executors"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:65
#: fd7e57489bf74199a450ffe14712bf24
msgid ""
"Currently, rclcpp provides three Executor types, derived from a shared "
"parent class:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:81
#: ed83289be546448bbad4d2a89ad88292
msgid ""
"The *Multi-Threaded Executor* creates a configurable number of threads to"
" allow for processing multiple messages or events in parallel. The "
"*Static Single-Threaded Executor* optimizes the runtime costs for "
"scanning the structure of a node in terms of subscriptions, timers, "
"service servers, action servers, etc. It performs this scan only once "
"when the node is added, while the other two executors regularly scan for "
"such changes. Therefore, the Static Single-Threaded Executor should be "
"used only with nodes that create all subscriptions, timers, etc. during "
"initialization."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:86
#: 4d2211b743ef4d02a3927107e6992a8c
msgid ""
"All three executors can be used with multiple nodes by calling "
"``add_node(..)`` for each node."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:100
#: 3098a5c32c9a469da320d8e2b1625e8f
msgid ""
"In the above example, the one thread of a Static Single-Threaded Executor"
" is used to serve three nodes together. In case of a Multi-Threaded "
"Executor, the actual parallelism depends on the callback groups."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:104
#: 06ff74eb344b4ac5898c7b0861ee97fd
msgid "Callback groups"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:106
#: f51f526beb9d41f3aaa7b8923a55366f
msgid ""
"ROS 2 allows organizing the callbacks of a node in groups. In rclcpp, "
"such a *callback group* can be created by the ``create_callback_group`` "
"function of the Node class. In rclpy, the same is done by calling the "
"constructor of the specific callback group type. The callback group must "
"be stored throughout execution of the node (eg. as a class member), or "
"otherwise the executor won't be able to trigger the callbacks. Then, this"
" callback group can be specified when creating a subscription, timer, "
"etc. - for example by the subscription options:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:114
#: 6f8faad6cd6c42fbac8c7acfc1d3125d
msgid "C++"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:125
#: f5368a582d0940ebb08bcfa60aa4783c
msgid "Python"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:133
#: 68bdee8fb1f24b04a49066159b013ec4
msgid ""
"All subscriptions, timers, etc. that are created without the indication "
"of a callback group are assigned to the *default callback group*. The "
"default callback group can be queried via "
"``NodeBaseInterface::get_default_callback_group()`` in rclcpp and by "
"``Node.default_callback_group`` in rclpy."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:137
#: 68a24d0508c04b40aeb63085ce4c117e
msgid ""
"There are two types of callback groups, where the type has to be "
"specified at instantiation time:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:139
#: bcd09e8f4529460d8cad7607fb23f266
msgid ""
"*Mutually exclusive:* Callbacks of this group must not be executed in "
"parallel."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:140
#: 65e5ddfc046d44fc9f2a512e509af792
msgid "*Reentrant:* Callbacks of this group may be executed in parallel."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:142
#: 1874b8dc64d24c3b9331fed3b38378b2
msgid ""
"Callbacks of different callback groups may always be executed in "
"parallel. The Multi-Threaded Executor uses its threads as a pool to "
"process as many callbacks as possible in parallel according to these "
"conditions. For tips on how to use callback groups efficiently, see "
":doc:`Using Callback Groups <../../How-To-Guides/Using-callback-groups>`."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:146
#: 8e61763a6fd441a8b3c5c7ceb470885e
msgid ""
"The Executor base class in rclcpp also has the function "
"``add_callback_group(..)``, which allows distributing callback groups to "
"different Executors. By configuring the underlying threads using the "
"operating system scheduler, specific callbacks can be prioritized over "
"other callbacks. For example, the subscriptions and timers of a control "
"loop can be prioritized over all other subscriptions and standard "
"services of a node. The `examples_rclcpp_cbg_executor package "
"<https://github.com/ros2/examples/tree/{REPOS_FILE_BRANCH}/rclcpp/executors/cbg_executor>`_"
" provides a demo of this mechanism."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:152
#: d7941c98c2fd4af1b001fe5a45e003da
msgid "Scheduling semantics"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:154
#: aa710856299a4828b5b9b30da4d3480a
msgid ""
"If the processing time of the callbacks is shorter than the period with "
"which messages and events occur, the Executor basically processes them in"
" FIFO order. However, if the processing time of some callbacks is longer,"
" messages and events will be queued on the lower layers of the stack. The"
" wait set mechanism reports only very little information about these "
"queues to the Executor. In detail, it only reports whether there are any "
"messages for a certain topic or not. The Executor uses this information "
"to process the messages (including services and actions) in a round-robin"
" fashion - but not in FIFO order. The following flow diagram visualizes "
"this scheduling semantics."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:163
#: ffbf5c07f36c4d0eb80530e17679b7d8
msgid ""
"This semantics was first described in a `paper by Casini et al. at ECRTS "
"2019 <https://drops.dagstuhl.de/opus/volltexte/2019/10743/pdf/LIPIcs-"
"ECRTS-2019-6.pdf>`_. (Note: The paper also explains that timer events are"
" prioritized over all other messages. `This prioritization was removed in"
" Eloquent. <https://github.com/ros2/rclcpp/pull/841>`_)"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:168
#: 8d104e19d001467c82b6f0396421bc2f
msgid "Outlook"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:170
#: f54a952c163744f9b544c3a13630c656
msgid ""
"While the three Executors of rclcpp work well for most applications, "
"there are some issues that make them not suitable for real-time "
"applications, which require well-defined execution times, determinism, "
"and custom control over the execution order. Here is a summary of some of"
" these issues:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:173
#: 0cb580c04a2f46cabd08d9ae1c584ffd
msgid ""
"Complex and mixed scheduling semantics. Ideally you want well defined "
"scheduling semantics to perform a formal timing analysis."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:175
#: 5a8b79fd2f864497a226211db2d36369
msgid ""
"Callbacks may suffer from priority inversion. Higher priority callbacks "
"may be blocked by lower priority callbacks."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:177
#: e393cfd058034cf8b5be360392e46b3a
msgid "No explicit control over the callbacks execution order."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:178
#: a0ae9a7e9bce4ed3be2491ce9e431647
msgid "No built-in control over triggering for specific topics."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:180
#: f1c967cd1d594c5ea05371c8c8234148
msgid ""
"Additionally, the executor overhead in terms of CPU and memory usage is "
"considerable. The Static Single-Threaded Executor reduces this overhead "
"greatly but it might not be enough for some applications."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:183
#: b04259488e654c34949f9a856c974ab8
msgid "These issues have been partially addressed by the following developments:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:185
#: afd9c0227ddd4b71be4843cca60ffdcd
msgid ""
"`rclcpp WaitSet "
"<https://github.com/ros2/rclcpp/blob/{REPOS_FILE_BRANCH}/rclcpp/include/rclcpp/wait_set.hpp>`_:"
" The ``WaitSet`` class of rclcpp allows waiting directly on "
"subscriptions, timers, service servers, action servers, etc. instead of "
"using an Executor. It can be used to implement deterministic, user-"
"defined processing sequences, possibly processing multiple messages from "
"different subscriptions together. The `examples_rclcpp_wait_set package "
"<https://github.com/ros2/examples/tree/{REPOS_FILE_BRANCH}/rclcpp/wait_set>`_"
" provides several examples for the use of this user-level wait set "
"mechanism."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:188
#: 8b2c6b11f383474992d63fe19d6c1030
msgid ""
"`rclc Executor "
"<https://github.com/ros2/rclc/blob/master/rclc/include/rclc/executor.h>`_:"
" This Executor from the C Client Library *rclc*, developed for micro-ROS,"
" gives the user fine-grained control over the execution order of "
"callbacks and allows for custom trigger conditions to activate callbacks."
" Furthermore, it implements ideas of the Logical Execution Time (LET) "
"semantics."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:192
#: fca2d78835f94328994457aeddb8b7b0
msgid "Further information"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:194
#: 67cac022c87e4c4fa9ead718a8bd9479
msgid ""
"Michael Pöhnl et al.: `\"ROS 2 Executor: How to make it efficient, real-"
"time and deterministic?\" <https://www.apex.ai/roscon-21>`_. Workshop at "
"ROS World 2021. Virtual event. 19 October 2021."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:195
#: 93b0a58718d24ef48101f4cf2724f7f4
msgid ""
"Ralph Lange: `\"Advanced Execution Management with ROS 2\" "
"<https://www.youtube.com/watch?v=Sz-nllmtcc8&t=109s>`_. ROS Industrial "
"Conference. Virtual event. 16 December 2020."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:196
#: fb2007361ff847b38df6ce7a97f70a86
msgid ""
"Daniel Casini, Tobias Blass, Ingo Lütkebohle, and Björn Brandenburg: "
"`“Response-Time Analysis of ROS 2 Processing Chains under Reservation-"
"Based Scheduling” "
"<https://drops.dagstuhl.de/opus/volltexte/2019/10743/pdf/LIPIcs-"
"ECRTS-2019-6.pdf>`_, Proc. of 31st ECRTS 2019, Stuttgart, Germany, July "
"2019."
msgstr ""

#~ msgid ""
#~ "Execution management in ROS 2 is "
#~ "handled by Executors. An Executor uses"
#~ " one or more threads of the "
#~ "underlying operating system to invoke "
#~ "the callbacks of subscriptions, timers, "
#~ "service servers, action servers, etc. on"
#~ " incoming messages and events. The "
#~ "explicit Executor class (in `executor.hpp "
#~ "<https://github.com/ros2/rclcpp/blob/rolling/rclcpp/include/rclcpp/executor.hpp>`_"
#~ " in rclcpp, in `executors.py "
#~ "<https://github.com/ros2/rclpy/blob/rolling/rclpy/rclpy/executors.py>`_"
#~ " in rclpy, or in `executor.h "
#~ "<https://github.com/ros2/rclc/blob/master/rclc/include/rclc/executor.h>`_"
#~ " in rclc) provides more control over"
#~ " execution management than the spin "
#~ "mechanism in ROS 1, although the "
#~ "basic API is very similar."
#~ msgstr ""

#~ msgid ""
#~ "The Executor base class in rclcpp "
#~ "also has the function "
#~ "``add_callback_group(..)``, which allows "
#~ "distributing callback groups to different "
#~ "Executors. By configuring the underlying "
#~ "threads using the operating system "
#~ "scheduler, specific callbacks can be "
#~ "prioritized over other callbacks. For "
#~ "example, the subscriptions and timers of"
#~ " a control loop can be prioritized"
#~ " over all other subscriptions and "
#~ "standard services of a node. The "
#~ "`examples_rclcpp_cbg_executor package "
#~ "<https://github.com/ros2/examples/tree/rolling/rclcpp/executors/cbg_executor>`_"
#~ " provides a demo of this mechanism."
#~ msgstr ""

#~ msgid ""
#~ "`rclcpp WaitSet "
#~ "<https://github.com/ros2/rclcpp/blob/rolling/rclcpp/include/rclcpp/wait_set.hpp>`_:"
#~ " The ``WaitSet`` class of rclcpp "
#~ "allows waiting directly on subscriptions, "
#~ "timers, service servers, action servers, "
#~ "etc. instead of using an Executor. "
#~ "It can be used to implement "
#~ "deterministic, user-defined processing "
#~ "sequences, possibly processing multiple "
#~ "messages from different subscriptions "
#~ "together. The `examples_rclcpp_wait_set package "
#~ "<https://github.com/ros2/examples/tree/rolling/rclcpp/wait_set>`_ "
#~ "provides several examples for the use"
#~ " of this user-level wait set "
#~ "mechanism."
#~ msgstr ""

