# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, Open Robotics
# This file is distributed under the same license as the ROS 2 documentation
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: ROS 2 documentation \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-08-19 11:55+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: es\n"
"Language-Team: es <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../source/Concepts/Intermediate/About-Executors.rst:6
#: 221085e0e5654080a028c0afbc8cb459
msgid "Executors"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:9
#: a42c65cad7b94bf7ae8f418c469d1601
msgid "Table of Contents"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:12
#: 50986457c4d743038043d32d1406b2c8
msgid "Overview"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:14
#: 47189587d14d4157ac07d9bf6abfb1d8
msgid ""
"Execution management in ROS 2 is handled by Executors. An Executor uses "
"one or more threads of the underlying operating system to invoke the "
"callbacks of subscriptions, timers, service servers, action servers, etc."
" on incoming messages and events. The explicit Executor class (in "
"`executor.hpp "
"<https://github.com/ros2/rclcpp/blob/rolling/rclcpp/include/rclcpp/executor.hpp>`_"
" in rclcpp, in `executors.py "
"<https://github.com/ros2/rclpy/blob/rolling/rclpy/rclpy/executors.py>`_ "
"in rclpy, or in `executor.h "
"<https://github.com/ros2/rclc/blob/master/rclc/include/rclc/executor.h>`_"
" in rclc) provides more control over execution management than the spin "
"mechanism in ROS 1, although the basic API is very similar."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:18
#: 4efe7f7cd83543d4a151f21b749d4204
msgid "In the following, we focus on the C++ Client Library *rclcpp*."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:21
#: 1a3e126b2ec8453ca160b6e3af8878ac
msgid "Basic use"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:23
#: 2f36811ffaca4efdbd4c610b1dc27b17
msgid ""
"In the simplest case, the main thread is used for processing the incoming"
" messages and events of a Node by calling ``rclcpp::spin(..)`` as "
"follows:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:44
#: 7ccb62e0115c4e828134b799b63c51ca
msgid ""
"The call to ``spin(node)`` basically expands to an instantiation and "
"invocation of the Single-Threaded Executor, which is the simplest "
"Executor:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:52
#: f291b036b65d45c1ae87160386738c99
msgid ""
"By invoking ``spin()`` of the Executor instance, the current thread "
"starts querying the rcl and middleware layers for incoming messages and "
"other events and calls the corresponding callback functions until the "
"node shuts down. In order not to counteract the QoS settings of the "
"middleware, an incoming message is not stored in a queue on the Client "
"Library layer but kept in the middleware until it is taken for processing"
" by a callback function. (This is a crucial difference to ROS 1.) A *wait"
" set* is used to inform the Executor about available messages on the "
"middleware layer, with one binary flag per queue. The *wait set* is also "
"used to detect when timers expire."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:60
#: 4059467897c14e0aa57adeba3b91d282
msgid ""
"The Single-Threaded Executor is also used by the container process for "
":doc:`components <./About-Composition>`, i.e. in all cases where nodes "
"are created and executed without an explicit main function."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:63
#: 7578561fb0954a6e8fe561816bbcd73c
msgid "Types of Executors"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:65
#: 0ca3954ca30e4829a1713d76558835bd
msgid ""
"Currently, rclcpp provides three Executor types, derived from a shared "
"parent class:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:81
#: d043c192be7d41099abb5a73c6df0140
msgid ""
"The *Multi-Threaded Executor* creates a configurable number of threads to"
" allow for processing multiple messages or events in parallel. The "
"*Static Single-Threaded Executor* optimizes the runtime costs for "
"scanning the structure of a node in terms of subscriptions, timers, "
"service servers, action servers, etc. It performs this scan only once "
"when the node is added, while the other two executors regularly scan for "
"such changes. Therefore, the Static Single-Threaded Executor should be "
"used only with nodes that create all subscriptions, timers, etc. during "
"initialization."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:86
#: 9723fc3b07624793a833c137d0771aef
msgid ""
"All three executors can be used with multiple nodes by calling "
"``add_node(..)`` for each node."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:100
#: 526db6dd92214dbcb9e5b3c94c777f8f
msgid ""
"In the above example, the one thread of a Static Single-Threaded Executor"
" is used to serve three nodes together. In case of a Multi-Threaded "
"Executor, the actual parallelism depends on the callback groups."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:104
#: 9aaba8d99be045f5b86141189b7f6078
msgid "Callback groups"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:106
#: 832751d2bcac4022bc28570c5df79fbd
msgid ""
"ROS 2 allows organizing the callbacks of a node in groups. In rclcpp, "
"such a *callback group* can be created by the ``create_callback_group`` "
"function of the Node class. In rclpy, the same is done by calling the "
"constructor of the specific callback group type. The callback group must "
"be stored throughout execution of the node (eg. as a class member), or "
"otherwise the executor won't be able to trigger the callbacks. Then, this"
" callback group can be specified when creating a subscription, timer, "
"etc. - for example by the subscription options:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:114
#: 7aa0318172bd4ed69a75b34a979e30fe
msgid "C++"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:125
#: ce37d68a4b014a508810c95053ca59ef
msgid "Python"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:133
#: 1d45329da8db4ef2874062b2e19bfccf
msgid ""
"All subscriptions, timers, etc. that are created without the indication "
"of a callback group are assigned to the *default callback group*. The "
"default callback group can be queried via "
"``NodeBaseInterface::get_default_callback_group()`` in rclcpp and by "
"``Node.default_callback_group`` in rclpy."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:137
#: 12cbedbf50214f8fbf8a22b6d5f4385b
msgid ""
"There are two types of callback groups, where the type has to be "
"specified at instantiation time:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:139
#: 67f1dffd86ef484ab252733e93a698ad
msgid ""
"*Mutually exclusive:* Callbacks of this group must not be executed in "
"parallel."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:140
#: 1c476601754e493b9acdce3ead1ead3d
msgid "*Reentrant:* Callbacks of this group may be executed in parallel."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:142
#: 7ba654fb4d5e407fac453db2cd3fa746
msgid ""
"Callbacks of different callback groups may always be executed in "
"parallel. The Multi-Threaded Executor uses its threads as a pool to "
"process as many callbacks as possible in parallel according to these "
"conditions. For tips on how to use callback groups efficiently, see "
":doc:`Using Callback Groups <../../How-To-Guides/Using-callback-groups>`."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:146
#: bbb00596485748ed953956c9a7a2a443
msgid ""
"The Executor base class in rclcpp also has the function "
"``add_callback_group(..)``, which allows distributing callback groups to "
"different Executors. By configuring the underlying threads using the "
"operating system scheduler, specific callbacks can be prioritized over "
"other callbacks. For example, the subscriptions and timers of a control "
"loop can be prioritized over all other subscriptions and standard "
"services of a node. The `examples_rclcpp_cbg_executor package "
"<https://github.com/ros2/examples/tree/rolling/rclcpp/executors/cbg_executor>`_"
" provides a demo of this mechanism."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:152
#: 6ac0c119be054ac898d2d426efbcd770
msgid "Scheduling semantics"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:154
#: 305e59e5db0446e1a4213cc1391ce05f
msgid ""
"If the processing time of the callbacks is shorter than the period with "
"which messages and events occur, the Executor basically processes them in"
" FIFO order. However, if the processing time of some callbacks is longer,"
" messages and events will be queued on the lower layers of the stack. The"
" wait set mechanism reports only very little information about these "
"queues to the Executor. In detail, it only reports whether there are any "
"messages for a certain topic or not. The Executor uses this information "
"to process the messages (including services and actions) in a round-robin"
" fashion - but not in FIFO order. The following flow diagram visualizes "
"this scheduling semantics."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:163
#: e879453a189b42e4a7813b52bc658ac6
msgid ""
"This semantics was first described in a `paper by Casini et al. at ECRTS "
"2019 <https://drops.dagstuhl.de/opus/volltexte/2019/10743/pdf/LIPIcs-"
"ECRTS-2019-6.pdf>`_. (Note: The paper also explains that timer events are"
" prioritized over all other messages. `This prioritization was removed in"
" Eloquent. <https://github.com/ros2/rclcpp/pull/841>`_)"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:168
#: 7b3262d2cffd44808a05f657926f54fe
msgid "Outlook"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:170
#: 34d01e917ef642f5add4cf43a94f7b33
msgid ""
"While the three Executors of rclcpp work well for most applications, "
"there are some issues that make them not suitable for real-time "
"applications, which require well-defined execution times, determinism, "
"and custom control over the execution order. Here is a summary of some of"
" these issues:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:173
#: 4c5c7f00f52d4cfe954ced2bf88b1526
msgid ""
"Complex and mixed scheduling semantics. Ideally you want well defined "
"scheduling semantics to perform a formal timing analysis."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:175
#: 7fb89d659e1b4035bc3bc2872f83ca3e
msgid ""
"Callbacks may suffer from priority inversion. Higher priority callbacks "
"may be blocked by lower priority callbacks."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:177
#: c3f6518051054356ac9353936258f268
msgid "No explicit control over the callbacks execution order."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:178
#: 159f0500aadc47ef835d940f90aaf91b
msgid "No built-in control over triggering for specific topics."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:180
#: 3002f209f7a646afb803f6196b262f10
msgid ""
"Additionally, the executor overhead in terms of CPU and memory usage is "
"considerable. The Static Single-Threaded Executor reduces this overhead "
"greatly but it might not be enough for some applications."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:183
#: a7e57a7e8807489c90525b9e8333eb7d
msgid "These issues have been partially addressed by the following developments:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:185
#: 01557195d66f48b384dbeaddeeddc9ac
msgid ""
"`rclcpp WaitSet "
"<https://github.com/ros2/rclcpp/blob/rolling/rclcpp/include/rclcpp/wait_set.hpp>`_:"
" The ``WaitSet`` class of rclcpp allows waiting directly on "
"subscriptions, timers, service servers, action servers, etc. instead of "
"using an Executor. It can be used to implement deterministic, user-"
"defined processing sequences, possibly processing multiple messages from "
"different subscriptions together. The `examples_rclcpp_wait_set package "
"<https://github.com/ros2/examples/tree/rolling/rclcpp/wait_set>`_ "
"provides several examples for the use of this user-level wait set "
"mechanism."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:188
#: e5cf48b4a9964f42a5eed51abbc5504e
msgid ""
"`rclc Executor "
"<https://github.com/ros2/rclc/blob/master/rclc/include/rclc/executor.h>`_:"
" This Executor from the C Client Library *rclc*, developed for micro-ROS,"
" gives the user fine-grained control over the execution order of "
"callbacks and allows for custom trigger conditions to activate callbacks."
" Furthermore, it implements ideas of the Logical Execution Time (LET) "
"semantics."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:192
#: 93d3b17577ad4887acf8b2dd07d7d044
msgid "Further information"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:194
#: f3cd8c4b91154efbb1f8134162c453f6
msgid ""
"Michael Pöhnl et al.: `\"ROS 2 Executor: How to make it efficient, real-"
"time and deterministic?\" <https://www.apex.ai/roscon-21>`_. Workshop at "
"ROS World 2021. Virtual event. 19 October 2021."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:195
#: 25a7095bb8e046a195b8fc4e0de53c38
msgid ""
"Ralph Lange: `\"Advanced Execution Management with ROS 2\" "
"<https://www.youtube.com/watch?v=Sz-nllmtcc8&t=109s>`_. ROS Industrial "
"Conference. Virtual event. 16 December 2020."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:196
#: e9632e3345ee4320a58778e8b043d925
msgid ""
"Daniel Casini, Tobias Blass, Ingo Lütkebohle, and Björn Brandenburg: "
"`“Response-Time Analysis of ROS 2 Processing Chains under Reservation-"
"Based Scheduling” "
"<https://drops.dagstuhl.de/opus/volltexte/2019/10743/pdf/LIPIcs-"
"ECRTS-2019-6.pdf>`_, Proc. of 31st ECRTS 2019, Stuttgart, Germany, July "
"2019."
msgstr ""

